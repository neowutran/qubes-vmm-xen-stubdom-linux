diff --git a/hw/xen/xen_pt.c b/hw/xen/xen_pt.c
index 36e6f93c3..51c006734 100644
--- a/hw/xen/xen_pt.c
+++ b/hw/xen/xen_pt.c
@@ -255,6 +255,8 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     uint32_t find_addr = addr;
     XenPTRegInfo *reg = NULL;
     bool wp_flag = false;
+    uint32_t emul_mask = 0, write_val;
+    uint32_t neowutran_val = val;
 
     if (xen_pt_pci_config_access_check(d, addr, len)) {
         return;
@@ -310,7 +312,8 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     }
 
     memory_region_transaction_begin();
-    pci_default_write_config(d, addr, val, len);
+    
+    xen_pt_log(d, "NEOWUTRAN QEMU 1: %x ; %x ; val: %x \n", addr, *(uint32_t*)(d->config + addr), val);
 
     /* adjust the read and write value to appropriate CFC-CFF window */
     read_val <<= (addr & 3) << 3;
@@ -342,6 +345,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
             switch (reg->size) {
             case 1:
                 if (reg->u.b.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU byte write: %x ; %x \n", read_val >> ((real_offset & 3) << 3), valid_mask);
                     rc = reg->u.b.write(s, reg_entry, ptr_val,
                                         read_val >> ((real_offset & 3) << 3),
                                         valid_mask);
@@ -349,6 +353,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                 break;
             case 2:
                 if (reg->u.w.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU word write: %x ; %x \n", read_val >> ((real_offset & 3) << 3), valid_mask);
                     rc = reg->u.w.write(s, reg_entry, (uint16_t *)ptr_val,
                                         (read_val >> ((real_offset & 3) << 3)),
                                         valid_mask);
@@ -356,6 +361,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                 break;
             case 4:
                 if (reg->u.dw.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU word write: %x ; %x \n", read_val >> ((real_offset & 3) << 3), valid_mask);
                     rc = reg->u.dw.write(s, reg_entry, (uint32_t *)ptr_val,
                                          (read_val >> ((real_offset & 3) << 3)),
                                          valid_mask);
@@ -370,6 +376,8 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                 return;
             }
 
+            emul_mask |= ( (1 << (reg->size * 8) ) - 1 ) << ((find_addr & 3) * 8);
+
             /* calculate next address to find */
             emul_len -= reg->size;
             if (emul_len > 0) {
@@ -396,6 +404,26 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     /* need to shift back before passing them to xen_host_pci_set_block. */
     val >>= (addr & 3) << 3;
 
+    /* store emulated registers after calling their handlers */
+    write_val = neowutran_val;
+    for (index = 0; index < len; index += emul_len) {
+        emul_len = 0;
+        while (emul_mask & 0xff) {
+            emul_len++;
+            emul_mask >>= 8;
+        }
+        if (emul_len) {
+            uint32_t mask = ((1 << (emul_len * 8)) - 1);
+            xen_pt_log(d, "NEOWUTRAN QEMU ACTUAl WRITE: %x ; %x ; val: %x ; mask : %x ; len: %x; index: %x \n", addr, *(uint32_t*)(d->config + addr), write_val & mask, mask, emul_len, index);
+
+            pci_default_write_config(d, addr + index, write_val & mask, emul_len);
+        } else {
+            emul_mask >>= 8;
+            emul_len = 1;
+        }
+        write_val >>= emul_len * 8;
+    }
+
     memory_region_transaction_commit();
 
 out:
