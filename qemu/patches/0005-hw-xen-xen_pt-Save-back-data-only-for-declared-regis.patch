diff --git a/hw/xen/xen_pt.c b/hw/xen/xen_pt.c
index 36e6f93c3..d030049eb 100644
--- a/hw/xen/xen_pt.c
+++ b/hw/xen/xen_pt.c
@@ -255,6 +255,8 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     uint32_t find_addr = addr;
     XenPTRegInfo *reg = NULL;
     bool wp_flag = false;
+    uint32_t emul_mask = 0, write_val;
+    uint32_t neowutran_val = val;
 
     if (xen_pt_pci_config_access_check(d, addr, len)) {
         return;
@@ -310,7 +312,8 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     }
 
     memory_region_transaction_begin();
-    pci_default_write_config(d, addr, val, len);
+    
+    xen_pt_log(d, "NEOWUTRAN QEMU 1: %x ; %x ; val: %x \n", addr, *(uint32_t*)(d->config + addr), val);
 
     /* adjust the read and write value to appropriate CFC-CFF window */
     read_val <<= (addr & 3) << 3;
@@ -329,19 +332,22 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
             uint32_t wp_mask = reg->emu_mask | reg->ro_mask;
 
             valid_mask <<= (find_addr - real_offset) << 3;
+            xen_pt_log(d, "NEOWUTRAN QEMU mask1: %x ; %x ; %x ; %x ; %x  \n", reg->emu_mask, reg->ro_mask, wp_mask, valid_mask,reg->offset);
             ptr_val = (uint8_t *)&val + (real_offset & 3);
             if (!s->permissive) {
                 wp_mask |= reg->res_mask;
             }
+            xen_pt_log(d, "NEOWUTRAN QEMU mask2: %x ; %x ; %x ; %x ; %x  \n", reg->emu_mask, reg->ro_mask, wp_mask, valid_mask,reg->offset);
             if (wp_mask == (0xFFFFFFFF >> ((4 - reg->size) << 3))) {
                 wb_mask &= ~((wp_mask >> ((find_addr - real_offset) << 3))
                              << ((len - emul_len) << 3));
             }
-
+            xen_pt_log(d, "NEOWUTRAN QEMU mask3: %x ; %x ; %x ; %x ; %x  \n", reg->emu_mask, reg->ro_mask, wp_mask, valid_mask,reg->offset);
             /* do emulation based on register size */
             switch (reg->size) {
             case 1:
                 if (reg->u.b.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU byte write: %x ; %x ; %x  \n", read_val >> ((real_offset & 3) << 3), valid_mask, reg->offset);
                     rc = reg->u.b.write(s, reg_entry, ptr_val,
                                         read_val >> ((real_offset & 3) << 3),
                                         valid_mask);
@@ -349,6 +355,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                 break;
             case 2:
                 if (reg->u.w.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU word write: %x ; %x ; %x \n", read_val >> ((real_offset & 3) << 3), valid_mask, reg->offset);
                     rc = reg->u.w.write(s, reg_entry, (uint16_t *)ptr_val,
                                         (read_val >> ((real_offset & 3) << 3)),
                                         valid_mask);
@@ -356,6 +363,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                 break;
             case 4:
                 if (reg->u.dw.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU dword write: %x ; %x ; %x \n", read_val >> ((real_offset & 3) << 3), valid_mask, reg->offset);
                     rc = reg->u.dw.write(s, reg_entry, (uint32_t *)ptr_val,
                                          (read_val >> ((real_offset & 3) << 3)),
                                          valid_mask);
@@ -369,6 +377,10 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                                          __func__, rc);
                 return;
             }
+            xen_pt_log(d, "NEOWUTRAN QEMU emul mask1: %x ; %x ; %x ; %x \n", emul_mask, reg->size, find_addr, reg->offset);
+            emul_mask |= ( (1 << (reg->size * 8) ) - 1 ) << ((find_addr & 3) * 8);
+            xen_pt_log(d, "NEOWUTRAN QEMU emul mask2: %x ; %x ; %x ; %x \n", emul_mask, reg->size, find_addr, reg->offset);
+
 
             /* calculate next address to find */
             emul_len -= reg->size;
@@ -396,6 +408,26 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     /* need to shift back before passing them to xen_host_pci_set_block. */
     val >>= (addr & 3) << 3;
 
+    /* store emulated registers after calling their handlers */
+    write_val = neowutran_val;
+    for (index = 0; index < len; index += emul_len) {
+        emul_len = 0;
+        while (emul_mask & 0xff) {
+            emul_len++;
+            emul_mask >>= 8;
+        }
+        if (emul_len) {
+            uint32_t mask = ((1 << (emul_len * 8)) - 1);
+            xen_pt_log(d, "NEOWUTRAN QEMU ACTUAl WRITE: %x ; %x ; val: %x ; mask : %x ; len: %x; index: %x \n", addr, *(uint32_t*)(d->config + addr), write_val & mask, mask, emul_len, index);
+
+            pci_default_write_config(d, addr + index, write_val & mask, emul_len);
+        } else {
+            emul_mask >>= 8;
+            emul_len = 1;
+        }
+        write_val >>= emul_len * 8;
+    }
+
     memory_region_transaction_commit();
 
 out:
