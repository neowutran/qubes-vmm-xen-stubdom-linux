diff --git a/hw/xen/xen_pt.c b/hw/xen/xen_pt.c
index 36e6f93c3..ff6fe1ff0 100644
--- a/hw/xen/xen_pt.c
+++ b/hw/xen/xen_pt.c
@@ -255,6 +255,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     uint32_t find_addr = addr;
     XenPTRegInfo *reg = NULL;
     bool wp_flag = false;
+    uint32_t emul_mask = 0, write_val = val;
 
     if (xen_pt_pci_config_access_check(d, addr, len)) {
         return;
@@ -310,7 +311,8 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
     }
 
     memory_region_transaction_begin();
-    pci_default_write_config(d, addr, val, len);
+    
+    xen_pt_log(d, "NEOWUTRAN QEMU 1: %x ; %x ; val: %x \n", addr, *(uint32_t*)(d->config + addr), val);
 
     /* adjust the read and write value to appropriate CFC-CFF window */
     read_val <<= (addr & 3) << 3;
@@ -329,19 +331,39 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
             uint32_t wp_mask = reg->emu_mask | reg->ro_mask;
 
             valid_mask <<= (find_addr - real_offset) << 3;
+            xen_pt_log(d, "NEOWUTRAN QEMU mask1: %x ; %x ; %x ; %x ; %x  \n", reg->emu_mask, reg->ro_mask, wp_mask, valid_mask,reg->offset);
             ptr_val = (uint8_t *)&val + (real_offset & 3);
             if (!s->permissive) {
                 wp_mask |= reg->res_mask;
             }
+            xen_pt_log(d, "NEOWUTRAN QEMU mask2: %x ; %x ; %x ; %x ; %x  \n", reg->emu_mask, reg->ro_mask, wp_mask, valid_mask,reg->offset);
             if (wp_mask == (0xFFFFFFFF >> ((4 - reg->size) << 3))) {
                 wb_mask &= ~((wp_mask >> ((find_addr - real_offset) << 3))
                              << ((len - emul_len) << 3));
             }
+            xen_pt_log(d, "NEOWUTRAN QEMU mask3: %x ; %x ; %x ; %x ; %x ; RO: %x \n", reg->emu_mask, reg->ro_mask, wp_mask, valid_mask,reg->offset, reg->ro_mask);
+            //if ( reg->ro_mask == 0 ) {
+            if ( reg->size + (reg->offset - addr) <= len ){
+               uint32_t neo_val;
+               if ( reg->size == 1 ){
+			neo_val = ((uint8_t)(read_val >> ((real_offset & 3) << 3)) & reg->ro_mask) | (*(uint8_t*)(d->config + addr + (reg->offset - addr)) ^ reg->ro_mask);
+               }else if ( reg->size == 2 ){
+                        neo_val = ((uint16_t)(read_val >> ((real_offset & 3) << 3)) & reg->ro_mask) | (*(uint16_t*)(d->config + addr + (reg->offset - addr)) ^ reg->ro_mask);
+		}else{
+                        neo_val = (read_val >> ((real_offset & 3) << 3) & reg->ro_mask) | (*(uint32_t*)(d->config + addr + (reg->offset - addr)) ^ reg->ro_mask);
+               }
+               xen_pt_log(d, "NEOWUTRAN QEMU ACTUAL WRITE %x %x %x \n", addr + (reg->offset - addr), neo_val, reg->size);
+               pci_default_write_config(d, addr + (reg->offset - addr), neo_val, reg->size);
+            }else{
+               xen_pt_log(d, "NEOWUTRAN QEMU SKIPPING WRITE TO %x \n", addr + (reg->offset - addr));
+            }
+
 
             /* do emulation based on register size */
             switch (reg->size) {
             case 1:
                 if (reg->u.b.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU byte write: %x ; %x ; %x  \n", read_val >> ((real_offset & 3) << 3), valid_mask, reg->offset);
                     rc = reg->u.b.write(s, reg_entry, ptr_val,
                                         read_val >> ((real_offset & 3) << 3),
                                         valid_mask);
@@ -349,6 +371,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                 break;
             case 2:
                 if (reg->u.w.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU word write: %x ; %x ; %x \n", read_val >> ((real_offset & 3) << 3), valid_mask, reg->offset);
                     rc = reg->u.w.write(s, reg_entry, (uint16_t *)ptr_val,
                                         (read_val >> ((real_offset & 3) << 3)),
                                         valid_mask);
@@ -356,6 +379,7 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                 break;
             case 4:
                 if (reg->u.dw.write) {
+                    xen_pt_log(d, "NEOWUTRAN QEMU dword write: %x ; %x ; %x \n", read_val >> ((real_offset & 3) << 3), valid_mask, reg->offset);
                     rc = reg->u.dw.write(s, reg_entry, (uint32_t *)ptr_val,
                                          (read_val >> ((real_offset & 3) << 3)),
                                          valid_mask);
@@ -369,6 +393,10 @@ static void xen_pt_pci_write_config(PCIDevice *d, uint32_t addr,
                                          __func__, rc);
                 return;
             }
+            //xen_pt_log(d, "NEOWUTRAN QEMU emul mask1: %x ; %x ; %x ; %x \n", emul_mask, reg->size, find_addr, reg->offset);
+            //emul_mask |= ( (1 << (reg->size * 8) ) - 1 ) << ((find_addr & 3) * 8);
+            //xen_pt_log(d, "NEOWUTRAN QEMU emul mask2: %x ; %x ; %x ; %x \n", emul_mask, reg->size, find_addr, reg->offset);
+
 
             /* calculate next address to find */
             emul_len -= reg->size;
