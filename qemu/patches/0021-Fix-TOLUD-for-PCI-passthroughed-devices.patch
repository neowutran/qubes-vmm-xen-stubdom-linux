From 2d7c35a4d7af621d98bfc4e639aac1ad76f55f8d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mateusz=20Pi=C3=B3rkowski?= <mati7337@protonmail.ch>
Date: Sat, 26 Mar 2022 03:06:35 +0100
Subject: [PATCH 21/21] Fix TOLUD for PCI passthroughed devices

---
 hw/i386/xen/xen-hvm.c | 73 ++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 72 insertions(+), 1 deletion(-)

diff --git a/hw/i386/pc_piix.c b/hw/i386/pc_piix.c
index ac72e8f5b..0b9cb9fcd 100644
--- a/hw/i386/pc_piix.c
+++ b/hw/i386/pc_piix.c
@@ -79,6 +79,10 @@ static const int ide_iobase2[MAX_IDE_BUS] = { 0x3f6, 0x376 };
 static const int ide_irq[MAX_IDE_BUS] = { 14, 15 };
 #endif
 
+#define DPRINTF(fmt, ...) do { \
+    fprintf(stderr, "xen_platform: " fmt, ## __VA_ARGS__); \
+} while (0)
+
 /*
  * Return the global irq number corresponding to a given device irq
  * pin. We could also use the bus number to have a more precise mapping.
@@ -158,9 +162,12 @@ static void pc_init1(MachineState *machine,
      *    qemu -M pc,max-ram-below-4g=2G -m 4G     -> 2048M low, 2048M high
      *    qemu -M pc,max-ram-below-4g=4G -m 3968M  -> 3968M low (=4G-128M)
      */
+    DPRINTF("NEOWUTRAN: PASSE B1\n");
     if (xen_enabled()) {
+        DPRINTF("NEOWUTRAN: START XEN PART\n");
         xen_hvm_init_pc(pcms, &ram_memory);
     } else {
+        DPRINTF("NEOWUTRAN: !!!! NON XEN PART !!!! \n");
         ram_memory = machine->ram;
         if (!pcms->max_ram_below_4g) {
             pcms->max_ram_below_4g = 0xe0000000; /* default: 3.5G */
@@ -197,6 +204,7 @@ static void pc_init1(MachineState *machine,
     }
 
     if (pcmc->pci_enabled) {
+        DPRINTF("NEOWUTRAN: PCI_ENABLED\n");
         Object *phb;
 
         pci_memory = g_new(MemoryRegion, 1);
@@ -220,6 +228,8 @@ static void pc_init1(MachineState *machine,
         object_property_set_str(phb, I440FX_HOST_PROP_PCI_TYPE, pci_type,
                                 &error_fatal);
         sysbus_realize_and_unref(SYS_BUS_DEVICE(phb), &error_fatal);
+        DPRINTF("NEOWUTRAN: below_4g_mem_size: %l\n", x86ms->below_4g_mem_size);
+        DPRINTF("NEOWUTRAN: above_4g_mem_size: %l\n", x86ms->above_4g_mem_size);
 
         pci_bus = PCI_BUS(qdev_get_child_bus(DEVICE(phb), "pci.0"));
         pci_bus_map_irqs(pci_bus,
@@ -230,6 +240,7 @@ static void pc_init1(MachineState *machine,
         hole64_size = object_property_get_uint(phb,
                                                PCI_HOST_PROP_PCI_HOLE64_SIZE,
                                                &error_abort);
+        DPRINTF("NEOWUTRAN: hole64_size: %l\n", hole64_size);
     }
 
     pc_guest_info_init(pcms);
@@ -245,13 +256,16 @@ static void pc_init1(MachineState *machine,
 
     /* allocate ram and load rom/bios */
     if (!xen_enabled()) {
+        DPRINTF("NEOWUTRAN: !!!!! 2 NOT XEN !!! \n");
         pc_memory_init(pcms, system_memory, rom_memory, hole64_size);
     } else {
+        DPRINTF("NEOWUTRAN: 2 XEN \n");
         assert(machine->ram_size == x86ms->below_4g_mem_size +
                                     x86ms->above_4g_mem_size);
 
         pc_system_flash_cleanup_unused(pcms);
         if (machine->kernel_filename != NULL) {
+        DPRINTF("NEOWUTRAN: C1 \n");
             /* For xen HVM direct kernel boot, load linux here */
             xen_load_linux(pcms);
         }
diff --git a/hw/i386/xen/xen-hvm.c b/hw/i386/xen/xen-hvm.c
index f42621e67..2b04c9774 100644
--- a/hw/i386/xen/xen-hvm.c
+++ b/hw/i386/xen/xen-hvm.c
@@ -112,6 +112,65 @@ qemu_irq *xen_interrupt_controller_init(void)
 
 /* Memory Ops */
 
+struct iomem_entry{
+    uint64_t addr_start;
+    uint64_t addr_end;
+    uint64_t name_len;
+    char *name;
+};
+
+int parse_iomem_entry(char *line, struct iomem_entry *entry)
+{
+    uint64_t pos = 0;
+
+    if (sscanf(line, "%llx-%llx : %lln", &entry->addr_start, &entry->addr_end, &pos) != 2) {
+        return -1;
+    }
+    entry->name = line + pos;
+    if (sscanf(line+pos, "%*s%lln\n", &entry->name_len) != 0) {
+        return -1;
+    }
+
+    return 0;
+}
+
+uint64_t get_min_pci_addr(void)
+{
+    FILE *iomem = fopen("/proc/iomem", "r");
+    if (iomem == NULL) {
+        return 0;
+    }
+
+    uint64_t iomem_line_bufsize = 128;
+    char *iomem_line = (char *)malloc(iomem_line_bufsize * sizeof(char));
+    if (iomem_line == NULL) {
+        fclose(iomem);
+        return 0;
+    }
+
+    uint64_t min_addr = 0;
+
+    while (getline(&iomem_line, &iomem_line_bufsize,iomem) != -1) {
+        struct iomem_entry entry;
+        if (parse_iomem_entry(iomem_line, &entry) != 0) {
+            continue;
+        }
+
+        uint64_t chars_match = 0;
+        if (sscanf(entry.name, "%*llx:%*llx:%*llx.%*llx%lln", &chars_match) != 0) {
+            break;
+        } else if (chars_match == entry.name_len) {
+            min_addr = entry.addr_start;
+            break;
+        }
+    }
+
+    free(iomem_line);
+    fclose(iomem);
+    return min_addr;
+}
+
+
 static void xen_ram_init(PCMachineState *pcms,
                          ram_addr_t ram_size, MemoryRegion **ram_memory_p)
 {
@@ -125,30 +184,58 @@ static void xen_ram_init(PCMachineState *pcms,
 
     /* Handle the machine opt max-ram-below-4g.  It is basically doing
      * min(xen limit, user limit).
+     *
+     * xen limit is calculated based on the min address of PCI devices
+     *
+     * TODO: hvmloader seems to relocate memory which overlaps with
+     * PCI addresses, but for some reason that doesn't work and it's
+     * required to lower max-ram-below-4g. Fixing that might solve the
+     * problem in a more elegant way.
      */
+    DPRINTF("NEOWUTRAN: user_lowmem: %l\n", user_lowmem );
+    DPRINTF("NEOWUTRAN: HVM_BELOW_4G_RAM_END: %l\n", HVM_BELOW_4G_RAM_END);
+
     if (!user_lowmem) {
-        user_lowmem = HVM_BELOW_4G_RAM_END; /* default */
+        DPRINTF("NEOWUTRAN: PASSE 1\n");
+        uint64_t min_pci_addr = get_min_pci_addr();
+        DPRINTF("NEOWUTRAN: min_pci_addr: %l", min_pci_addr);
+        if (min_pci_addr && min_pci_addr < HVM_BELOW_4G_RAM_END) {
+            DPRINTF("NEOWUTRAN: PASSE 2\n");
+            user_lowmem = min_pci_addr;
+        } else {
+            DPRINTF("NEOWUTRAN: PASSE 3\n");
+            user_lowmem = HVM_BELOW_4G_RAM_END;
+        }
     }
+
     if (HVM_BELOW_4G_RAM_END <= user_lowmem) {
+        DPRINTF("NEOWUTRAN: PASSE 4\n");
         user_lowmem = HVM_BELOW_4G_RAM_END;
     }
 
+    DPRINTF("NEOWUTRAN: ram_size: %l", ram_size);
+    DPRINTF("NEOWUTRAN: user_lowmem: %l", user_lowmem);
     if (ram_size >= user_lowmem) {
+        DPRINTF("NEOWUTRAN: PASSE 5\n");
         x86ms->above_4g_mem_size = ram_size - user_lowmem;
         x86ms->below_4g_mem_size = user_lowmem;
     } else {
+        DPRINTF("NEOWUTRAN: PASSE 6\n");
         x86ms->above_4g_mem_size = 0;
         x86ms->below_4g_mem_size = ram_size;
     }
     if (!x86ms->above_4g_mem_size) {
+        DPRINTF("NEOWUTRAN: PASSE 7\n");
         block_len = ram_size;
     } else {
+        DPRINTF("NEOWUTRAN: PASSE 8\n");
         /*
          * Xen does not allocate the memory continuously, it keeps a
          * hole of the size computed above or passed in.
          */
         block_len = (4 * GiB) + x86ms->above_4g_mem_size;
     }
+    DPRINTF("NEOWUTRAN: block_len: %l", block_len);
     memory_region_init_ram(&ram_memory, NULL, "xen.ram", block_len,
                            &error_fatal);
     *ram_memory_p = &ram_memory;
@@ -679,12 +766,16 @@ void arch_xen_set_memory(XenIOState *state, MemoryRegionSection *section,
 
     start_addr &= TARGET_PAGE_MASK;
     size = TARGET_PAGE_ALIGN(size);
+    DPRINTF("NEOWUTRAN: SET MEMORY: start_addr: %l, size: %l\n", start_addr, size);
 
     if (add) {
+        DPRINTF("NEOWUTRAN: PASSE A1\n");
         if (!memory_region_is_rom(section->mr)) {
+        DPRINTF("NEOWUTRAN: PASSE A2\n");
             xen_add_to_physmap(state, start_addr, size,
                                section->mr, section->offset_within_region);
         } else {
+        DPRINTF("NEOWUTRAN: PASSE A3\n");
             mem_type = HVMMEM_ram_ro;
             if (xen_set_mem_type(xen_domid, mem_type,
                                  start_addr >> TARGET_PAGE_BITS,
@@ -694,7 +785,9 @@ void arch_xen_set_memory(XenIOState *state, MemoryRegionSection *section,
             }
         }
     } else {
+        DPRINTF("NEOWUTRAN: PASSE A4\n");
         if (xen_remove_from_physmap(state, start_addr, size) < 0) {
+        DPRINTF("NEOWUTRAN: PASSE A5\n");
             DPRINTF("physmapping does not exist at "HWADDR_FMT_plx"\n", start_addr);
         }
     }
diff --git a/hw/i386/xen/xen_platform.c b/hw/i386/xen/xen_platform.c
index 17457ff3d..2d3d119cf 100644
--- a/hw/i386/xen/xen_platform.c
+++ b/hw/i386/xen/xen_platform.c
@@ -50,7 +50,9 @@
     fprintf(stderr, "xen_platform: " fmt, ## __VA_ARGS__); \
 } while (0)
 #else
-#define DPRINTF(fmt, ...) do { } while (0)
+#define DPRINTF(fmt, ...) do { \
+    fprintf(stderr, "xen_platform: " fmt, ## __VA_ARGS__); \
+} while (0)
 #endif
 
 #define PFFLAG_ROM_LOCK 1 /* Sets whether ROM memory area is RW or RO */
diff --git a/include/hw/xen/xen-hvm-common.h b/include/hw/xen/xen-hvm-common.h
index 4e9904f1a..2293a9ae0 100644
--- a/include/hw/xen/xen-hvm-common.h
+++ b/include/hw/xen/xen-hvm-common.h
@@ -27,7 +27,8 @@ extern DeviceListener xen_device_listener;
     do { fprintf(stderr, "xen: " fmt, ## __VA_ARGS__); } while (0)
 #else
 #define DPRINTF(fmt, ...) \
-    do { } while (0)
+    do { fprintf(stderr, "xen: " fmt, ## __VA_ARGS__); } while (0)
+
 #endif
 
 static inline uint32_t xen_vcpu_eport(shared_iopage_t *shared_page, int i)

-- 
2.41.0
